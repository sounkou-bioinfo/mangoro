---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```



[![mangoro status badge](https://sounkou-bioinfo.r-universe.dev/mangoro/badges/version)](https://sounkou-bioinfo.r-universe.dev/mangoro)


# mangoro 


R/Go IPC with Nanomsg Next Gen.

<p>
<img src="inst/docs/logo.svg" alt="" width="180" align="right"/>
</p>

## What is mangoro?

Beside being the way mangos is said in [bambara](https://bm.wikipedia.org/wiki/Mangoro) (derived from portugese as it happens), in this package we vendor the [mangos/v3](https://github.com/nanomsg/mangos) and [arrow-go](https://github.com/apache/arrow-go) Go packages for IPC between R and Go processes using the `nanonext` and `nanoarrow` R packages on the R side. The package provides helper functions to build Go binaries that use mangos and Arrow for IPC. This is a basic setup that can be used as a starting point for more complex R/Go IPC applications. In our opinion, this approach avoids the complexities and limitations of cgo's c-shared mode, which can lead to issues with loading multiple Go runtimes in the same R session as discussed in this R-package-devel mailing list thread: [CRAN Policy on Go using Packages](https://hypatia.math.ethz.ch/pipermail/r-package-devel/2025q4/012067.html).


## On-the-fly Go compilation and echo

Compile some go code on-the-fly from R using the `mangoro_go_build()` function. This uses the vendored go code in [inst/go/vendor](inst/go/vendor)

```{r echo-compile, message=TRUE, warning=TRUE}

library(nanonext)
library(processx)
library(nanoarrow)
library(mangoro)

# vendored mangos version
get_mangos_version()
go_echo_code <- paste(
  'package main',
  'import (',
  '  "os"',
  '  "go.nanomsg.org/mangos/v3/protocol/rep"',
  '  _ "go.nanomsg.org/mangos/v3/transport/ipc"',
  ')',
  'func main() {',
  '  url := os.Args[1]',
  '  sock, _ := rep.NewSocket()',
  '  sock.Listen(url)',
  '  for {',
  '    msg, _ := sock.Recv()',
  '    newMsg := append(msg, []byte(" [echoed by Go]")...)',
  '    sock.Send(newMsg)',
  '  }',
  '}',
  sep = "\n"
)

tmp_go <- tempfile(fileext = ".go")
writeLines(go_echo_code, tmp_go)

tmp_bin <- tempfile()
mangoro_go_build(tmp_go, tmp_bin)
```

create IPC path and send/receive message

```{r echo-run, message=TRUE, warning=TRUE}
ipc_url <- create_ipc_path()
echo_proc <- processx::process$new(tmp_bin, args = ipc_url)
Sys.sleep(1)
echo_proc$is_alive()
sock <- nanonext::socket("req", dial = ipc_url)
msg <- charToRaw("hello from R")

max_attempts <- 20
send_result <- nanonext::send(sock, msg, mode = "raw")
attempt <- 1
while (nanonext::is_error_value(send_result) && attempt < max_attempts) {
  Sys.sleep(1)
  send_result <- nanonext::send(sock, msg, mode = "raw")
  attempt <- attempt + 1
}

response <- nanonext::recv(sock, mode = "raw")
attempt <- 1
while (nanonext::is_error_value(response) && attempt < max_attempts) {
  Sys.sleep(1)
  response <- nanonext::recv(sock, mode = "raw")
  attempt <- attempt + 1
}

rawToChar(response)
close(sock)
echo_proc$kill()
```

## Arrow IPC with nanoarrow for serialization 

Compile go code this time that uses Arrow IPC for (de)serialization between R and Go.

```{r arrow-ipc-compile, message=TRUE, warning=TRUE}

cfg <- nanonext::serial_config(
  "ArrowTabular",
  nanoarrow::write_nanoarrow,
  nanoarrow::read_nanoarrow
)
ipc_url <- create_ipc_path()
go_code <- '
package main
import (
  "os"
  "bytes"
  "fmt"
  "go.nanomsg.org/mangos/v3/protocol/rep"
  _ "go.nanomsg.org/mangos/v3/transport/ipc"
  "github.com/apache/arrow/go/v18/arrow/ipc"
  "github.com/apache/arrow/go/v18/arrow/memory"
)
func main() {
  url := os.Args[1]
  sock, _ := rep.NewSocket()
  sock.Listen(url)
  for {
    msg, _ := sock.Recv()
    reader, err := ipc.NewReader(bytes.NewReader(msg), ipc.WithAllocator(memory.DefaultAllocator))
    if err != nil {
      fmt.Println("Arrow IPC error:", err)
      continue
    }
    var buf bytes.Buffer
    writer := ipc.NewWriter(&buf, ipc.WithSchema(reader.Schema()))
    for reader.Next() {
      rec := reader.Record()
      fmt.Println(rec)
      if err := writer.Write(rec); err != nil {
        fmt.Println("Arrow IPC write error:", err)
      }
      rec.Release()
    }
    if err := writer.Close(); err != nil {
      fmt.Println("Arrow IPC writer close error:", err)
    }
    reader.Release()
    sock.Send(buf.Bytes())
  }
}
'
tmp_go <- tempfile(fileext = ".go")
writeLines(go_code, tmp_go)
tmp_bin <- tempfile()
mangoro_go_build(tmp_go, tmp_bin)

echo_proc <- processx::process$new(tmp_bin, args = ipc_url, stdout = "|", stderr = "|"  )
Sys.sleep(3)
```

Configure the socket and send/receive an Arrow IPC data. Note that we use a loop with retries to handle potential timing issues when the Go echo server is not yet ready to receive messages.

```{r arrow-ipc-data, message=TRUE, warning=TRUE}
echo_proc$is_alive()
sock <- nanonext::socket("req", dial = ipc_url)
nanonext::opt(sock, "serial") <- cfg

example_stream <- nanoarrow::example_ipc_stream()
max_attempts <- 20
send_result <- nanonext::send(sock, example_stream, mode = "raw")
attempt <- 1
while (nanonext::is_error_value(send_result) && attempt < max_attempts) {
  Sys.sleep(1)
  send_result <- nanonext::send(sock, example_stream, mode = "raw")
  attempt <- attempt + 1
}
send_result
echo_proc$is_alive()
Sys.sleep(1)
received <- nanonext::recv(sock, mode = "serial")
attempt <- 1
while (nanonext::is_error_value(received) && attempt < max_attempts) {
  Sys.sleep(1)
  received <- nanonext::recv(sock, mode = "serial")
  attempt <- attempt + 1
}
sent_df <- as.data.frame(read_nanoarrow(example_stream))
received_df <- as.data.frame(read_nanoarrow(received))
sent_df
received_df
identical(sent_df, received_df)
close(sock)
echo_proc$kill()
```

## Simple RPC with Function Registration

The package includes `rgoipc`, a Go package for building RPC servers with function registration. Functions are registered in the Go main application and called by R.

### RPC Message Structure

The RPC protocol wraps Arrow IPC data in a simple envelope:

```
[type:1byte][name_len:4bytes][name][error_len:4bytes][error][arrow_ipc_data]
```

- **Type**: Message type (0=manifest, 1=call, 2=result, 3=error)
- **Name length + Name**: Function name (empty for manifest requests)
- **Error length + Error**: Error message (empty on success)
- **Arrow IPC data**: 
  - For **manifest response**: JSON bytes describing available functions
  - For **function calls**: Arrow IPC stream containing input arguments (typically RecordBatch)
  - For **function results**: Arrow IPC stream containing output (typically RecordBatch)

Both the input and output data are serialized using Arrow IPC format. The Go server receives Arrow IPC (as `arrow.Record`), processes it, and returns Arrow IPC. On the R side, you can work with data frames, nanoarrow streams, or any Arrow-compatible structure. The thin RPC envelope only adds metadata (function name, error handling) around the Arrow data.

```{r rpc-build}

rpc_server_path <- file.path(system.file("go", package = "mangoro"), "cmd", "rpc-example", "main.go")
rpc_bin <- tempfile()
mangoro_go_build(rpc_server_path, rpc_bin)

ipc_url <- create_ipc_path()
rpc_proc <- processx::process$new(rpc_bin, args = ipc_url, stdout = "|", stderr = "|")
Sys.sleep(2)
rpc_proc$is_alive()
```

Request the manifest of registered functions:

```{r rpc-manifest}
sock <- nanonext::socket("req", dial = ipc_url)
manifest <- mangoro_rpc_get_manifest(sock)
manifest
close(sock)
```

Call the `add` function with Arrow IPC data:

```{r rpc-call}
sock <- nanonext::socket("req", dial = ipc_url)

input_df <- data.frame(x = c(1.5, 2.5, 3.5, NA), y = c(0.5, 1.5, 2.5, 4.5))
result <- mangoro_rpc_call(sock, "add", input_df)
result_df <- as.data.frame(result)

input_df
result_df
input_df$x + input_df$y

close(sock)
```

Call the `echoString` function to test string handling:

```{r rpc-echo-string}
sock <- nanonext::socket("req", dial = ipc_url)

input_df <- data.frame(s = c("hello", "world", NA, "mangoro"))
result <- mangoro_rpc_call(sock, "echoString", input_df)
result_df <- as.data.frame(result)

input_df
result_df
identical(input_df$s, result_df$result)

close(sock)
```

Call the `transposeMatrix` function to demonstrate matrix handling. In R, we send a matrix as a data.frame (each column is a column), and Go transposes it:

```{r rpc-transpose-matrix}
sock <- nanonext::socket("req", dial = ipc_url)

# Create a 3x4 matrix and convert to data.frame for Arrow IPC
mat <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), nrow = 3, ncol = 4)
"Input matrix (3x4):"
mat

# Convert to data.frame - each column becomes a column
input_df <- as.data.frame(mat)
colnames(input_df) <- paste0("V", 1:ncol(mat))

# Transpose via RPC
result <- mangoro_rpc_call(sock, "transposeMatrix", input_df)
result_df <- as.data.frame(result)

# Compare values (ignore dimnames)
all.equal(as.matrix(result_df), t(mat), check.attributes = FALSE)

close(sock)
rpc_proc$kill()
```

## HTTP File Server with RPC Control

The package includes an HTTP file server that can be controlled via RPC, demonstrating a slighly more complex use case.

```{r http-server-build}
# Build the HTTP server controller
http_server_path <- file.path(system.file("go", package = "mangoro"), "cmd", "http-server", "main.go")
http_bin <- tempfile()
mangoro_go_build(http_server_path, http_bin, gomaxprocs = 4)

# Start the RPC controller (not the HTTP server itself yet)
ipc_url <- create_ipc_path()
http_ctl_proc <- processx::process$new(http_bin, args = ipc_url, stdout = "|", stderr = "|")
Sys.sleep(2)
http_ctl_proc$is_alive()
http_ctl_proc$read_output_lines()
```

Control the HTTP server via RPC:

```{r http-server-control}
sock <- nanonext::socket("req", dial = ipc_url)

# Get server status (should be stopped initially)
status <- mangoro_http_status(sock)
status

# Start HTTP server on port 8080 serving current directory
result <- mangoro_http_start(sock, "127.0.0.1:8080", dir = ".", cors = TRUE)
result

# Check status again
status <- mangoro_http_status(sock)
status

# Test accessing the HTTP server
readLines("http://127.0.0.1:8080/", n = 3, warn = FALSE)

# Stop the server
result <- mangoro_http_stop(sock)
result

# Verify it stopped
status <- mangoro_http_status(sock)
status

close(sock)
http_ctl_proc$kill()
```


The `rgoipc` package provides the interfaces for type-safe function registration with Arrow schema validation. See [inst/go/pkg/rgoipc](inst/go/pkg/rgoipc) for the Go package implementation and [inst/go/cmd/rpc-example](inst/go/cmd/rpc-example) and [inst/go/cmd/http-server](inst/go/cmd/http-server) for complete server examples.

## Some issues to investigate 
There is some convertion overhead now when sending data to go processes because we are sending the arrow data as bytes. Moroever for some reason, we cannot send directly matrices.

## LLM Usage Disclosure

Code and documentation in this project have been generated with the assistance of the github Copilot LLM tools. While we have reviewed and edited the generated content, we acknowledge that LLM tools were used in the creation process and accordingly (since these models are trained on GPL code and other commons + proprietary software license is fake anyway) the code is released under GPL-3. So if you use this code in any way, you must comply with the GPL-3 license.